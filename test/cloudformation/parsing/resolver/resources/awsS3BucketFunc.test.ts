import log from 'loglevel';
import { awsS3BucketFunc } from '../../../../../src/cloudformation/parsing/resolver/resources/awsS3BucketFunc';
import { ResolvingContext } from '../../../../../src/cloudformation/parsing/types/types';
import {
    generateAlphaNumeric,
    resolveStringWithDefault,
    shortUuid,
} from '../../../../../src/cloudformation/parsing/utils/helper-utils';
import { AwsS3BucketResource } from '../../../../../src/cloudformation/types/cloudformation-model';

// Mock helper functions to control their outputs.
jest.mock('../../../../../src/cloudformation/parsing/utils/helper-utils', () => ({
    generateAlphaNumeric: jest.fn(() => 'MOCKED_ID'),
    resolveStringWithDefault: jest.fn(
        (_prop: unknown, defaultValue: string, _propName: string, _ctx: ResolvingContext) => defaultValue,
    ),
    shortUuid: jest.fn(() => 'SHORT_UUID'),
}));

/**
 * Creates a fresh mock ResolvingContext for testing.
 *
 * @returns A mock ResolvingContext.
 */
function createMockContext(): ResolvingContext {
    return {
        originalTemplate: {},
        lookupMapPreProcessed: {},
        generatedIds: new Set(),
        lookupMapDynamic: {},
        currentPath: [],
        addName: jest.fn(),
        popName: jest.fn(() => ''),
        getCurrentPath: jest.fn(() => ''),
        hasParameterName: jest.fn(() => false),
        getParameter: jest.fn(),
        addParameter: jest.fn(),
        addGeneratedId: jest.fn(),
        isIdExists: jest.fn(() => false),
        getRegion: jest.fn(() => 'us-east-1'),
        getPartition: jest.fn(() => 'aws'),
        getAccountId: jest.fn(() => '123456789012'),
        getAZs: jest.fn(() => ['us-east-1a', 'us-east-1b']),
    } as unknown as ResolvingContext;
}

describe('awsS3BucketFunc', () => {
    let mockCtx: ResolvingContext;
    let resource: AwsS3BucketResource;

    beforeEach(() => {
        // Reset previous calls on helper mocks.
        (generateAlphaNumeric as jest.Mock).mockClear();
        (resolveStringWithDefault as jest.Mock).mockClear();
        (shortUuid as jest.Mock).mockClear();

        // Create a fresh mock context and resource for every test.
        mockCtx = createMockContext();
        resource = {
            Properties: {
                // For awsS3BucketFunc, the resource-specific property is BucketName.
                BucketName: 'dummyBucketName',
            },
        } as AwsS3BucketResource;

        // Ensure _id and _arn are not preset.
        delete resource._id;
        delete resource._arn;
    });

    describe('idGenFunc', () => {
        it('should generate a new ID if not already set', () => {
            // If BucketName exists, idGenFunc calls resolveStringWithDefault.
            // It uses the default value: `bucket-${shortUuid(ctx)}`.
            // shortUuid returns 'SHORT_UUID', so default becomes "bucket-SHORT_UUID".
            const id = awsS3BucketFunc.idGenFunc('AWS::S3::Bucket', 'TestLogicalId', resource, mockCtx);
            const expectedDefault = 'bucket-SHORT_UUID';
            // Expect resolveStringWithDefault to be called with:
            // property: 'dummyBucketName', defaultValue: expectedDefault,
            // propertyName: 'AWS::S3::Bucket.Properties.BucketName'
            expect(resolveStringWithDefault).toHaveBeenCalledWith(
                'dummyBucketName',
                expectedDefault,
                'AWS::S3::Bucket.Properties.BucketName',
                mockCtx,
            );
            expect(id).toBe(expectedDefault);
            expect(resource._id).toBe(expectedDefault);
            expect(shortUuid).toHaveBeenCalledWith(mockCtx);
        });

        it('should return the existing ID if already set', () => {
            resource._id = 'existingBucketId';
            const id = awsS3BucketFunc.idGenFunc('AWS::S3::Bucket', 'TestLogicalId', resource, mockCtx);
            expect(id).toBe('existingBucketId');
            expect(generateAlphaNumeric).not.toHaveBeenCalled();
            expect(resolveStringWithDefault).not.toHaveBeenCalled();
            expect(shortUuid).not.toHaveBeenCalled();
        });
    });

    describe('refFunc', () => {
        it('should return the ID generated by idGenFunc', () => {
            const id = awsS3BucketFunc.refFunc('AWS::S3::Bucket', 'TestLogicalId', resource, mockCtx);
            // refFunc returns the same value as idGenFunc.
            expect(id).toBe(resource._id || 'bucket-SHORT_UUID');
        });
    });

    describe('getAttFunc', () => {
        it('should return the ARN when key is "Arn"', () => {
            const att = awsS3BucketFunc.getAttFunc('AWS::S3::Bucket', 'Arn', 'TestLogicalId', resource, mockCtx);
            // arnGenFunc will be called; it constructs the ARN as:
            // arn:{partition}:s3:::{bucketName}
            // bucketName is the value returned by idGenFunc (default "bucket-SHORT_UUID")
            const expectedArn = 'arn:aws:s3:::bucket-SHORT_UUID';
            expect(att).toBe(expectedArn);
        });

        it('should return RUNTIME_DomainName when key is "DomainName"', () => {
            const att = awsS3BucketFunc.getAttFunc('AWS::S3::Bucket', 'DomainName', 'TestLogicalId', resource, mockCtx);
            expect(att).toBe('RUNTIME_DomainName');
        });

        it('should return RUNTIME_DualStackDomainName when key is "DualStackDomainName"', () => {
            const att = awsS3BucketFunc.getAttFunc(
                'AWS::S3::Bucket',
                'DualStackDomainName',
                'TestLogicalId',
                resource,
                mockCtx,
            );
            expect(att).toBe('RUNTIME_DualStackDomainName');
        });

        it('should return resolved value for MetadataTableConfiguration.S3TablesDestination.TableArn', () => {
            // Setup resource with nested property.
            (resource as AwsS3BucketResource).Properties.MetadataTableConfiguration = {
                S3TablesDestination: {
                    TableArn: 'dummyTableArn',
                    TableNamespace: 'dummyNamespace',
                    TableBucketArn: 'dummyBucketArn',
                    TableName: 'dummyTableName',
                },
            };
            const att = awsS3BucketFunc.getAttFunc(
                'AWS::S3::Bucket',
                'MetadataTableConfiguration.S3TablesDestination.TableArn',
                'TestLogicalId',
                resource,
                mockCtx,
            );
            // Our mocked resolveStringWithDefault returns its default argument.
            expect(resolveStringWithDefault).toHaveBeenCalledWith(
                'dummyTableArn',
                'RUNTIME_MetadataTableConfiguration',
                'AWS::S3::Bucket.Properties.MetadataTableConfiguration?.S3TablesDestination.TableArn',
                mockCtx,
            );
            expect(att).toBe('RUNTIME_MetadataTableConfiguration');
        });

        it('should return resolved value for MetadataTableConfiguration.S3TablesDestination.TableNamespace', () => {
            // Setup resource with nested property.
            (resource as AwsS3BucketResource).Properties.MetadataTableConfiguration = {
                S3TablesDestination: {
                    TableArn: 'dummyTableArn',
                    TableNamespace: 'dummyNamespace',
                    TableBucketArn: 'dummyBucketArn',
                    TableName: 'dummyTableName',
                },
            };
            (resolveStringWithDefault as jest.Mock).mockReturnValueOnce('dummyNamespace');

            const att = awsS3BucketFunc.getAttFunc(
                'AWS::S3::Bucket',
                'MetadataTableConfiguration.S3TablesDestination.TableNamespace',
                'dummyNamespace',
                resource,
                mockCtx,
            );
            expect(resolveStringWithDefault).toHaveBeenCalledWith(
                'dummyNamespace',
                'RUNTIME_MetadataTableConfiguration',
                'AWS::S3::Bucket.Properties.MetadataTableConfiguration?.S3TablesDestination.TableNamespace',
                mockCtx,
            );
            expect(att).toBe('dummyNamespace');
        });

        it('should return RUNTIME_RegionalDomainName when key is "RegionalDomainName"', () => {
            const att = awsS3BucketFunc.getAttFunc(
                'AWS::S3::Bucket',
                'RegionalDomainName',
                'TestLogicalId',
                resource,
                mockCtx,
            );
            expect(att).toBe('RUNTIME_RegionalDomainName');
        });

        it('should return RUNTIME_WebsiteURL when key is "WebsiteURL"', () => {
            const att = awsS3BucketFunc.getAttFunc('AWS::S3::Bucket', 'WebsiteURL', 'TestLogicalId', resource, mockCtx);
            expect(att).toBe('RUNTIME_WebsiteURL');
        });

        it('should warn and return the ID for unsupported keys', () => {
            const warnSpy = jest.spyOn(log, 'warn').mockImplementation(() => {});
            const att = awsS3BucketFunc.getAttFunc(
                'AWS::S3::Bucket',
                'UnsupportedKey',
                'TestLogicalId',
                resource,
                mockCtx,
            );
            const expectedId = resource._id || 'bucket-SHORT_UUID';
            expect(att).toBe(expectedId);
            expect(warnSpy).toHaveBeenCalledWith(
                `Passed key UnsupportedKey for AWS::S3::Bucket, with logicalId=TestLogicalId is not supported, id will be returned`,
                resource,
                mockCtx,
            );
            warnSpy.mockRestore();
        });
    });

    describe('arnGenFunc', () => {
        it('should generate and assign a new ARN if none exists', () => {
            const arn = awsS3BucketFunc.arnGenFunc('AWS::S3::Bucket', 'TestLogicalId', resource, mockCtx);
            // idGenFunc returns default bucket name: "bucket-SHORT_UUID"
            // ARN format: arn:{partition}:s3:::{bucketName}
            const expectedArn = 'arn:aws:s3:::bucket-SHORT_UUID';
            expect(arn).toBe(expectedArn);
            expect(resource._arn).toBe(expectedArn);
            // Verify helper calls.
            expect(shortUuid).toHaveBeenCalledWith(mockCtx);
            expect(resolveStringWithDefault).toHaveBeenCalledWith(
                'dummyBucketName',
                'bucket-SHORT_UUID',
                'AWS::S3::Bucket.Properties.BucketName',
                mockCtx,
            );
        });

        it('should return the existing ARN if it is already set', () => {
            resource._arn = 'existingArn';
            const arn = awsS3BucketFunc.arnGenFunc('AWS::S3::Bucket', 'TestLogicalId', resource, mockCtx);
            expect(arn).toBe('existingArn');
        });
    });
});
